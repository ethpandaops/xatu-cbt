// Code generated by clickhouse-proto-gen. DO NOT EDIT.
// This file provides common SQL query building helpers.

package clickhouse

import (
	"encoding/base64"
	"fmt"
	"regexp"
	"strings"
)

// VariableSubstitutionStyle defines the placeholder style for SQL parameters
type VariableSubstitutionStyle int

const (
	// VariableSubstitutionStandard uses ? placeholders.
	VariableSubstitutionStandard VariableSubstitutionStyle = iota
	// VariableSubstitutionPositional uses $1, $2, $3... placeholders.
	VariableSubstitutionPositional
)

// QueryBuilderOptions configures QueryBuilder behavior
type QueryBuilderOptions struct {
	VariableSubstitution VariableSubstitutionStyle
}

// QueryBuilderOption is a functional option for QueryBuilder configuration
type QueryBuilderOption func(*QueryBuilderOptions)

// WithVariableSubstitution sets the variable substitution style
func WithVariableSubstitution(style VariableSubstitutionStyle) QueryBuilderOption {
	return func(opts *QueryBuilderOptions) {
		opts.VariableSubstitution = style
	}
}

// QueryOptions configures SQL query generation behavior
type QueryOptions struct {
	// AddFinal adds FINAL modifier after table name for ClickHouse MergeTree tables
	AddFinal bool
}

// QueryOption is a functional option for query configuration
type QueryOption func(*QueryOptions)

// WithFinal adds the FINAL modifier to the query
func WithFinal() QueryOption {
	return func(opts *QueryOptions) {
		opts.AddFinal = true
	}
}

// SQLQuery represents a parameterized SQL query
type SQLQuery struct {
	Query  string
	Args   []interface{}
}

// QueryBuilder helps construct parameterized SQL queries safely
type QueryBuilder struct {
	conditions []string
	args       []interface{}
	argCounter int
	options    *QueryBuilderOptions
}

// NewQueryBuilder creates a new query builder with optional configuration
func NewQueryBuilder(options ...QueryBuilderOption) *QueryBuilder {
	opts := &QueryBuilderOptions{
		VariableSubstitution: VariableSubstitutionStandard, // Default to ? style
	}

	for _, opt := range options {
		opt(opts)
	}

	return &QueryBuilder{
		conditions: make([]string, 0),
		args:       make([]interface{}, 0),
		argCounter: 1,
		options:    opts,
	}
}

// formatVariable returns the appropriate placeholder for the given argument index
func (qb *QueryBuilder) formatVariable(index int) string {
	switch qb.options.VariableSubstitution {
	case VariableSubstitutionPositional:
		return fmt.Sprintf("$%d", index)
	case VariableSubstitutionStandard:
		return "?"
	default:
		return "?" // Default to standard style
	}
}

// AddCondition adds a condition with a parameterized value
func (qb *QueryBuilder) AddCondition(column, operator string, value interface{}) {
	placeholder := qb.formatVariable(qb.argCounter)
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s %s %s", column, operator, placeholder))
	qb.args = append(qb.args, value)
	qb.argCounter++
}

// AddBetweenCondition adds a BETWEEN condition
func (qb *QueryBuilder) AddBetweenCondition(column string, minValue, maxValue interface{}) {
	placeholderMin := qb.formatVariable(qb.argCounter)
	qb.argCounter++
	placeholderMax := qb.formatVariable(qb.argCounter)
	qb.argCounter++
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s BETWEEN %s AND %s", column, placeholderMin, placeholderMax))
	qb.args = append(qb.args, minValue, maxValue)
}

// AddInCondition adds an IN condition
func (qb *QueryBuilder) AddInCondition(column string, values []interface{}) {
	if len(values) == 0 {
		return
	}
	placeholders := make([]string, len(values))
	for i, v := range values {
		placeholders[i] = qb.formatVariable(qb.argCounter)
		qb.args = append(qb.args, v)
		qb.argCounter++
	}
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IN (%s)", column, strings.Join(placeholders, ", ")))
}

// AddNotInCondition adds a NOT IN condition
func (qb *QueryBuilder) AddNotInCondition(column string, values []interface{}) {
	if len(values) == 0 {
		return
	}
	placeholders := make([]string, len(values))
	for i, v := range values {
		placeholders[i] = qb.formatVariable(qb.argCounter)
		qb.args = append(qb.args, v)
		qb.argCounter++
	}
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s NOT IN (%s)", column, strings.Join(placeholders, ", ")))
}

// AddLikeCondition adds a LIKE condition with proper escaping
func (qb *QueryBuilder) AddLikeCondition(column, pattern string) {
	placeholder := qb.formatVariable(qb.argCounter)
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s LIKE %s", column, placeholder))
	qb.args = append(qb.args, pattern)
	qb.argCounter++
}

// AddNotLikeCondition adds a NOT LIKE condition
func (qb *QueryBuilder) AddNotLikeCondition(column, pattern string) {
	placeholder := qb.formatVariable(qb.argCounter)
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s NOT LIKE %s", column, placeholder))
	qb.args = append(qb.args, pattern)
	qb.argCounter++
}

// AddIsNullCondition adds an IS NULL condition
func (qb *QueryBuilder) AddIsNullCondition(column string) {
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IS NULL", column))
}

// AddIsNotNullCondition adds an IS NOT NULL condition
func (qb *QueryBuilder) AddIsNotNullCondition(column string) {
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IS NOT NULL", column))
}

// GetWhereClause returns the WHERE clause if conditions exist
func (qb *QueryBuilder) GetWhereClause() string {
	if len(qb.conditions) == 0 {
		return ""
	}
	return " WHERE " + strings.Join(qb.conditions, " AND ")
}

// GetArgs returns the query arguments
func (qb *QueryBuilder) GetArgs() []interface{} {
	return qb.args
}


// Helper functions for converting filter values to interface{}

func UInt32SliceToInterface(values []uint32) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func UInt64SliceToInterface(values []uint64) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func Int32SliceToInterface(values []int32) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func Int64SliceToInterface(values []int64) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func StringSliceToInterface(values []string) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}
// EncodePageToken encodes an offset as an opaque page token
func EncodePageToken(offset uint32) string {
	if offset == 0 {
		return ""
	}
	// Create an opaque token by base64 encoding the offset
	return base64.URLEncoding.EncodeToString([]byte(fmt.Sprintf("offset:%d", offset)))
}

// DecodePageToken decodes a page token back to an offset
func DecodePageToken(pageToken string) (uint32, error) {
	if pageToken == "" {
		return 0, nil
	}
	data, err := base64.URLEncoding.DecodeString(pageToken)
	if err != nil {
		return 0, fmt.Errorf("invalid page token format: %w", err)
	}
	var offset uint32
	n, err := fmt.Sscanf(string(data), "offset:%d", &offset)
	if err != nil || n != 1 {
		return 0, fmt.Errorf("invalid page token content")
	}
	return offset, nil
}

// CalculateNextPageToken calculates the next page token based on current offset and results
func CalculateNextPageToken(currentOffset, limit, resultCount uint32) string {
	// If we got fewer results than the limit, we've reached the end
	if resultCount < limit {
		return ""
	}
	// Calculate next offset
	nextOffset := currentOffset + resultCount
	return EncodePageToken(nextOffset)
}

// OrderByField represents a parsed order by field with direction
type OrderByField struct {
	Field string
	Desc  bool
}

// ParseOrderBy parses an AIP-132 compliant order_by string
// Format: "field1,field2 desc,field3"
func ParseOrderBy(orderBy string, validFields []string) ([]OrderByField, error) {
	if orderBy == "" {
		return nil, nil
	}

	// Create a map of valid fields for quick lookup
	validFieldMap := make(map[string]bool)
	for _, f := range validFields {
		validFieldMap[f] = true
	}

	var result []OrderByField

	// Split by comma
	parts := strings.Split(orderBy, ",")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}

		var field string
		var desc bool

		// Check if it ends with " desc"
		if strings.HasSuffix(strings.ToLower(part), " desc") {
			field = strings.TrimSpace(part[:len(part)-5])
			desc = true
		} else if strings.HasSuffix(strings.ToLower(part), " asc") {
			// Also support explicit " asc" even though it's the default
			field = strings.TrimSpace(part[:len(part)-4])
			desc = false
		} else {
			field = part
			desc = false
		}

		// Validate field name (only alphanumeric, underscore, and dots allowed)
		validFieldRegex := regexp.MustCompile("^[a-zA-Z0-9_.]+$")
		if !validFieldRegex.MatchString(field) {
			return nil, fmt.Errorf("invalid field name: %s", field)
		}

		// Check if field is valid (if validFields provided)
		if len(validFields) > 0 {
			// For subfields like "address.street", check the base field
			baseField := strings.Split(field, ".")[0]
			if !validFieldMap[baseField] {
				return nil, fmt.Errorf("invalid field for ordering: %s", field)
			}
		}

		result = append(result, OrderByField{
			Field: field,
			Desc:  desc,
		})
	}

	return result, nil
}

// BuildOrderByClause builds an ORDER BY clause from parsed order by fields
func BuildOrderByClause(fields []OrderByField) string {
	if len(fields) == 0 {
		return ""
	}

	var parts []string
	for _, f := range fields {
		if f.Desc {
			parts = append(parts, fmt.Sprintf("%s DESC", f.Field))
		} else {
			parts = append(parts, f.Field)
		}
	}

	return " ORDER BY " + strings.Join(parts, ", ")
}

// BuildParameterizedQuery constructs the final parameterized query with optional ordering
func BuildParameterizedQuery(database, table string, qb *QueryBuilder, orderByClause string, limit, offset uint32, options ...QueryOption) SQLQuery {
	// Apply options
	opts := &QueryOptions{}
	for _, opt := range options {
		opt(opts)
	}

	// Build FROM clause with optional FINAL
	fromClause := fmt.Sprintf("%s.%s", database, table)
	if opts.AddFinal {
		fromClause += " FINAL"
	}

	query := fmt.Sprintf("SELECT * FROM %s", fromClause)

	// Add WHERE clause
	query += qb.GetWhereClause()

	// Add ORDER BY clause
	query += orderByClause

	// Add LIMIT and OFFSET
	if limit > 0 {
		query += fmt.Sprintf(" LIMIT %d", limit)
		if offset > 0 {
			query += fmt.Sprintf(" OFFSET %d", offset)
		}
	}

	return SQLQuery{
		Query: query,
		Args:  qb.GetArgs(),
	}
}
