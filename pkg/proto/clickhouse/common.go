// Code generated by clickhouse-proto-gen. DO NOT EDIT.
// This file provides common SQL query building helpers.

package clickhouse

import (
	"encoding/base64"
	"fmt"
	"regexp"
	"strings"
)

// SQLQuery represents a parameterized SQL query
type SQLQuery struct {
	Query  string
	Args   []interface{}
}

// QueryBuilder helps construct parameterized SQL queries safely
type QueryBuilder struct {
	conditions []string
	args       []interface{}
	argCounter int
}

// NewQueryBuilder creates a new query builder
func NewQueryBuilder() *QueryBuilder {
	return &QueryBuilder{
		conditions: make([]string, 0),
		args:       make([]interface{}, 0),
		argCounter: 1,
	}
}

// AddCondition adds a condition with a parameterized value
func (qb *QueryBuilder) AddCondition(column, operator string, value interface{}) {
	placeholder := fmt.Sprintf("$%d", qb.argCounter)
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s %s %s", column, operator, placeholder))
	qb.args = append(qb.args, value)
	qb.argCounter++
}

// AddBetweenCondition adds a BETWEEN condition
func (qb *QueryBuilder) AddBetweenCondition(column string, min, max interface{}) {
	placeholderMin := fmt.Sprintf("$%d", qb.argCounter)
	qb.argCounter++
	placeholderMax := fmt.Sprintf("$%d", qb.argCounter)
	qb.argCounter++
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s BETWEEN %s AND %s", column, placeholderMin, placeholderMax))
	qb.args = append(qb.args, min, max)
}

// AddInCondition adds an IN condition
func (qb *QueryBuilder) AddInCondition(column string, values []interface{}) {
	if len(values) == 0 {
		return
	}
	placeholders := make([]string, len(values))
	for i, v := range values {
		placeholders[i] = fmt.Sprintf("$%d", qb.argCounter)
		qb.args = append(qb.args, v)
		qb.argCounter++
	}
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IN (%s)", column, strings.Join(placeholders, ", ")))
}

// AddNotInCondition adds a NOT IN condition
func (qb *QueryBuilder) AddNotInCondition(column string, values []interface{}) {
	if len(values) == 0 {
		return
	}
	placeholders := make([]string, len(values))
	for i, v := range values {
		placeholders[i] = fmt.Sprintf("$%d", qb.argCounter)
		qb.args = append(qb.args, v)
		qb.argCounter++
	}
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s NOT IN (%s)", column, strings.Join(placeholders, ", ")))
}

// AddLikeCondition adds a LIKE condition with proper escaping
func (qb *QueryBuilder) AddLikeCondition(column, pattern string) {
	placeholder := fmt.Sprintf("$%d", qb.argCounter)
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s LIKE %s", column, placeholder))
	qb.args = append(qb.args, pattern)
	qb.argCounter++
}

// AddIsNullCondition adds an IS NULL condition
func (qb *QueryBuilder) AddIsNullCondition(column string) {
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IS NULL", column))
}

// AddIsNotNullCondition adds an IS NOT NULL condition
func (qb *QueryBuilder) AddIsNotNullCondition(column string) {
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IS NOT NULL", column))
}

// GetWhereClause returns the WHERE clause if conditions exist
func (qb *QueryBuilder) GetWhereClause() string {
	if len(qb.conditions) == 0 {
		return ""
	}
	return " WHERE " + strings.Join(qb.conditions, " AND ")
}

// GetArgs returns the query arguments
func (qb *QueryBuilder) GetArgs() []interface{} {
	return qb.args
}

// BuildQuery constructs the final parameterized query
func BuildParameterizedQuery(database, table string, qb *QueryBuilder, sortingKeys []string, limit, offset uint32) SQLQuery {
	query := fmt.Sprintf("SELECT * FROM %s.%s", database, table)
	
	// Add WHERE clause
	query += qb.GetWhereClause()
	
	// Add ORDER BY
	if len(sortingKeys) > 0 {
		query += " ORDER BY " + strings.Join(sortingKeys, ", ")
	}
	
	// Add LIMIT and OFFSET
	if limit > 0 {
		query += fmt.Sprintf(" LIMIT %d", limit)
		if offset > 0 {
			query += fmt.Sprintf(" OFFSET %d", offset)
		}
	}
	
	return SQLQuery{
		Query: query,
		Args:  qb.GetArgs(),
	}
}

// Helper functions for converting filter values to interface{}

func UInt32SliceToInterface(values []uint32) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func UInt64SliceToInterface(values []uint64) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func Int32SliceToInterface(values []int32) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func Int64SliceToInterface(values []int64) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func StringSliceToInterface(values []string) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}
// EncodePageToken encodes an offset as an opaque page token
func EncodePageToken(offset uint32) string {
	if offset == 0 {
		return ""
	}
	// Create an opaque token by base64 encoding the offset
	return base64.URLEncoding.EncodeToString([]byte(fmt.Sprintf("offset:%d", offset)))
}

// DecodePageToken decodes a page token back to an offset
func DecodePageToken(pageToken string) (uint32, error) {
	if pageToken == "" {
		return 0, nil
	}
	data, err := base64.URLEncoding.DecodeString(pageToken)
	if err != nil {
		return 0, fmt.Errorf("invalid page token format: %w", err)
	}
	var offset uint32
	n, err := fmt.Sscanf(string(data), "offset:%d", &offset)
	if err != nil || n != 1 {
		return 0, fmt.Errorf("invalid page token content")
	}
	return offset, nil
}

// CalculateNextPageToken calculates the next page token based on current offset and results
func CalculateNextPageToken(currentOffset, limit, resultCount uint32) string {
	// If we got fewer results than the limit, we've reached the end
	if resultCount < limit {
		return ""
	}
	// Calculate next offset
	nextOffset := currentOffset + resultCount
	return EncodePageToken(nextOffset)
}

// OrderByField represents a parsed order by field with direction
type OrderByField struct {
	Field string
	Desc  bool
}

// ParseOrderBy parses an AIP-132 compliant order_by string
// Format: "field1,field2 desc,field3"
func ParseOrderBy(orderBy string, validFields []string) ([]OrderByField, error) {
	if orderBy == "" {
		return nil, nil
	}

	// Create a map of valid fields for quick lookup
	validFieldMap := make(map[string]bool)
	for _, f := range validFields {
		validFieldMap[f] = true
	}

	var result []OrderByField
	
	// Split by comma
	parts := strings.Split(orderBy, ",")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}

		var field string
		var desc bool

		// Check if it ends with " desc"
		if strings.HasSuffix(strings.ToLower(part), " desc") {
			field = strings.TrimSpace(part[:len(part)-5])
			desc = true
		} else if strings.HasSuffix(strings.ToLower(part), " asc") {
			// Also support explicit " asc" even though it's the default
			field = strings.TrimSpace(part[:len(part)-4])
			desc = false
		} else {
			field = part
			desc = false
		}

		// Validate field name (only alphanumeric, underscore, and dots allowed)
		validFieldRegex := regexp.MustCompile("^[a-zA-Z0-9_.]+$")
		if !validFieldRegex.MatchString(field) {
			return nil, fmt.Errorf("invalid field name: %s", field)
		}

		// Check if field is valid (if validFields provided)
		if len(validFields) > 0 {
			// For subfields like "address.street", check the base field
			baseField := strings.Split(field, ".")[0]
			if !validFieldMap[baseField] {
				return nil, fmt.Errorf("invalid field for ordering: %s", field)
			}
		}

		result = append(result, OrderByField{
			Field: field,
			Desc:  desc,
		})
	}

	return result, nil
}

// BuildOrderByClause builds an ORDER BY clause from parsed order by fields
func BuildOrderByClause(fields []OrderByField) string {
	if len(fields) == 0 {
		return ""
	}

	var parts []string
	for _, f := range fields {
		if f.Desc {
			parts = append(parts, fmt.Sprintf("%s DESC", f.Field))
		} else {
			parts = append(parts, f.Field)
		}
	}

	return " ORDER BY " + strings.Join(parts, ", ")
}

// BuildParameterizedQueryWithOrder constructs the final parameterized query with custom ordering
func BuildParameterizedQueryWithOrder(database, table string, qb *QueryBuilder, orderByClause string, limit, offset uint32) SQLQuery {
	query := fmt.Sprintf("SELECT * FROM %s.%s", database, table)
	
	// Add WHERE clause
	query += qb.GetWhereClause()
	
	// Add ORDER BY clause
	query += orderByClause
	
	// Add LIMIT and OFFSET
	if limit > 0 {
		query += fmt.Sprintf(" LIMIT %d", limit)
		if offset > 0 {
			query += fmt.Sprintf(" OFFSET %d", offset)
		}
	}
	
	return SQLQuery{
		Query: query,
		Args:  qb.GetArgs(),
	}
}
