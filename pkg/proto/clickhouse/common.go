// Code generated by clickhouse-proto-gen. DO NOT EDIT.
// This file provides common SQL query building helpers.

package clickhouse

import (
	"encoding/base64"
	"fmt"
	"regexp"
	"strings"
)

// VariableSubstitutionStyle defines the placeholder style for SQL parameters
type VariableSubstitutionStyle int

const (
	// VariableSubstitutionStandard uses ? placeholders.
	VariableSubstitutionStandard VariableSubstitutionStyle = iota
	// VariableSubstitutionPositional uses $1, $2, $3... placeholders.
	VariableSubstitutionPositional
)

// QueryBuilderOptions configures QueryBuilder behavior
type QueryBuilderOptions struct {
	VariableSubstitution VariableSubstitutionStyle
}

// QueryBuilderOption is a functional option for QueryBuilder configuration
type QueryBuilderOption func(*QueryBuilderOptions)

// WithVariableSubstitution sets the variable substitution style
func WithVariableSubstitution(style VariableSubstitutionStyle) QueryBuilderOption {
	return func(opts *QueryBuilderOptions) {
		opts.VariableSubstitution = style
	}
}

// QueryOptions configures SQL query generation behavior
type QueryOptions struct {
	// AddFinal adds FINAL modifier after table name for ClickHouse MergeTree tables
	AddFinal bool
	// Database optionally specifies the database name
	Database string
	// Projection optionally specifies the projection to use
	Projection string
}

// QueryOption is a functional option for query configuration
type QueryOption func(*QueryOptions)

// WithFinal adds the FINAL modifier to the query
func WithFinal() QueryOption {
	return func(opts *QueryOptions) {
		opts.AddFinal = true
	}
}

// WithDatabase specifies the database to query from
func WithDatabase(database string) QueryOption {
	return func(opts *QueryOptions) {
		opts.Database = database
	}
}

// WithProjection specifies the projection to use
func WithProjection(projection string) QueryOption {
	return func(opts *QueryOptions) {
		opts.Projection = projection
	}
}

// SQLQuery represents a parameterized SQL query
type SQLQuery struct {
	Query  string
	Args   []interface{}
}

// DateTimeValue wraps a uint32 Unix timestamp for proper DateTime handling in ClickHouse
type DateTimeValue struct {
	Timestamp uint32
}

// DateTime64Value wraps a uint64 Unix timestamp for proper DateTime64 handling in ClickHouse
type DateTime64Value struct {
	Timestamp uint64
}

// QueryBuilder helps construct parameterized SQL queries safely
type QueryBuilder struct {
	conditions []string
	args       []interface{}
	argCounter int
	options    *QueryBuilderOptions
}

// NewQueryBuilder creates a new query builder with optional configuration
func NewQueryBuilder(options ...QueryBuilderOption) *QueryBuilder {
	opts := &QueryBuilderOptions{
		VariableSubstitution: VariableSubstitutionStandard, // Default to ? style
	}

	for _, opt := range options {
		opt(opts)
	}

	return &QueryBuilder{
		conditions: make([]string, 0),
		args:       make([]interface{}, 0),
		argCounter: 1,
		options:    opts,
	}
}

// formatVariable returns the appropriate placeholder for the given argument index
func (qb *QueryBuilder) formatVariable(index int) string {
	switch qb.options.VariableSubstitution {
	case VariableSubstitutionPositional:
		return fmt.Sprintf("$%d", index)
	case VariableSubstitutionStandard:
		return "?"
	default:
		return "?" // Default to standard style
	}
}

// AddCondition adds a condition with a parameterized value
func (qb *QueryBuilder) AddCondition(column, operator string, value interface{}) {
	placeholder := qb.formatVariable(qb.argCounter)

	// Check if value is a DateTime wrapper and handle accordingly
	switch v := value.(type) {
	case DateTimeValue:
		// For DateTime values, wrap with fromUnixTimestamp
		qb.conditions = append(qb.conditions, fmt.Sprintf("%s %s fromUnixTimestamp(%s)", column, operator, placeholder))
		qb.args = append(qb.args, v.Timestamp)
	case DateTime64Value:
		// For DateTime64 values, wrap with fromUnixTimestamp64Micro
		qb.conditions = append(qb.conditions, fmt.Sprintf("%s %s fromUnixTimestamp64Micro(%s)", column, operator, placeholder))
		qb.args = append(qb.args, v.Timestamp)
	default:
		// Regular value
		qb.conditions = append(qb.conditions, fmt.Sprintf("%s %s %s", column, operator, placeholder))
		qb.args = append(qb.args, value)
	}
	qb.argCounter++
}

// AddBetweenCondition adds a BETWEEN condition
func (qb *QueryBuilder) AddBetweenCondition(column string, minValue, maxValue interface{}) {
	placeholderMin := qb.formatVariable(qb.argCounter)
	qb.argCounter++
	placeholderMax := qb.formatVariable(qb.argCounter)
	qb.argCounter++

	// Check if values are DateTime wrappers
	switch minValue.(type) {
	case DateTimeValue:
		minV := minValue.(DateTimeValue)
		maxV := maxValue.(DateTimeValue)
		qb.conditions = append(qb.conditions, fmt.Sprintf("%s BETWEEN fromUnixTimestamp(%s) AND fromUnixTimestamp(%s)",
			column, placeholderMin, placeholderMax))
		qb.args = append(qb.args, minV.Timestamp, maxV.Timestamp)
	case DateTime64Value:
		minV := minValue.(DateTime64Value)
		maxV := maxValue.(DateTime64Value)
		qb.conditions = append(qb.conditions, fmt.Sprintf("%s BETWEEN fromUnixTimestamp64Micro(%s) AND fromUnixTimestamp64Micro(%s)",
			column, placeholderMin, placeholderMax))
		qb.args = append(qb.args, minV.Timestamp, maxV.Timestamp)
	default:
		qb.conditions = append(qb.conditions, fmt.Sprintf("%s BETWEEN %s AND %s", column, placeholderMin, placeholderMax))
		qb.args = append(qb.args, minValue, maxValue)
	}
}

// AddInCondition adds an IN condition
func (qb *QueryBuilder) AddInCondition(column string, values []interface{}) {
	if len(values) == 0 {
		return
	}

	// Check if first value is a DateTime wrapper to determine handling
	if len(values) > 0 {
		switch values[0].(type) {
		case DateTimeValue:
			placeholders := make([]string, len(values))
			for i, v := range values {
				dt := v.(DateTimeValue)
				placeholders[i] = fmt.Sprintf("fromUnixTimestamp(%s)", qb.formatVariable(qb.argCounter))
				qb.args = append(qb.args, dt.Timestamp)
				qb.argCounter++
			}
			qb.conditions = append(qb.conditions, fmt.Sprintf("%s IN (%s)", column, strings.Join(placeholders, ", ")))
			return
		case DateTime64Value:
			placeholders := make([]string, len(values))
			for i, v := range values {
				dt := v.(DateTime64Value)
				placeholders[i] = fmt.Sprintf("fromUnixTimestamp64Micro(%s)", qb.formatVariable(qb.argCounter))
				qb.args = append(qb.args, dt.Timestamp)
				qb.argCounter++
			}
			qb.conditions = append(qb.conditions, fmt.Sprintf("%s IN (%s)", column, strings.Join(placeholders, ", ")))
			return
		}
	}

	// Regular values
	placeholders := make([]string, len(values))
	for i, v := range values {
		placeholders[i] = qb.formatVariable(qb.argCounter)
		qb.args = append(qb.args, v)
		qb.argCounter++
	}
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IN (%s)", column, strings.Join(placeholders, ", ")))
}

// AddNotInCondition adds a NOT IN condition
func (qb *QueryBuilder) AddNotInCondition(column string, values []interface{}) {
	if len(values) == 0 {
		return
	}

	// Check if first value is a DateTime wrapper to determine handling
	if len(values) > 0 {
		switch values[0].(type) {
		case DateTimeValue:
			placeholders := make([]string, len(values))
			for i, v := range values {
				dt := v.(DateTimeValue)
				placeholders[i] = fmt.Sprintf("fromUnixTimestamp(%s)", qb.formatVariable(qb.argCounter))
				qb.args = append(qb.args, dt.Timestamp)
				qb.argCounter++
			}
			qb.conditions = append(qb.conditions, fmt.Sprintf("%s NOT IN (%s)", column, strings.Join(placeholders, ", ")))
			return
		case DateTime64Value:
			placeholders := make([]string, len(values))
			for i, v := range values {
				dt := v.(DateTime64Value)
				placeholders[i] = fmt.Sprintf("fromUnixTimestamp64Micro(%s)", qb.formatVariable(qb.argCounter))
				qb.args = append(qb.args, dt.Timestamp)
				qb.argCounter++
			}
			qb.conditions = append(qb.conditions, fmt.Sprintf("%s NOT IN (%s)", column, strings.Join(placeholders, ", ")))
			return
		}
	}

	// Regular values
	placeholders := make([]string, len(values))
	for i, v := range values {
		placeholders[i] = qb.formatVariable(qb.argCounter)
		qb.args = append(qb.args, v)
		qb.argCounter++
	}
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s NOT IN (%s)", column, strings.Join(placeholders, ", ")))
}

// AddLikeCondition adds a LIKE condition with proper escaping
func (qb *QueryBuilder) AddLikeCondition(column, pattern string) {
	placeholder := qb.formatVariable(qb.argCounter)
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s LIKE %s", column, placeholder))
	qb.args = append(qb.args, pattern)
	qb.argCounter++
}

// AddNotLikeCondition adds a NOT LIKE condition
func (qb *QueryBuilder) AddNotLikeCondition(column, pattern string) {
	placeholder := qb.formatVariable(qb.argCounter)
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s NOT LIKE %s", column, placeholder))
	qb.args = append(qb.args, pattern)
	qb.argCounter++
}

// AddIsNullCondition adds an IS NULL condition
func (qb *QueryBuilder) AddIsNullCondition(column string) {
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IS NULL", column))
}

// AddIsNotNullCondition adds an IS NOT NULL condition
func (qb *QueryBuilder) AddIsNotNullCondition(column string) {
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IS NOT NULL", column))
}

// AddMapKeyCondition adds a condition for accessing a map key value
func (qb *QueryBuilder) AddMapKeyCondition(column, key, operator string, value interface{}) {
	placeholder := qb.formatVariable(qb.argCounter)
	// Escape the key for SQL safety
	escapedKey := strings.ReplaceAll(key, "'", "''")
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s['%s'] %s %s", column, escapedKey, operator, placeholder))
	qb.args = append(qb.args, value)
	qb.argCounter++
}

// AddMapKeyLikeCondition adds a LIKE condition for a map key value
func (qb *QueryBuilder) AddMapKeyLikeCondition(column, key, pattern string) {
	placeholder := qb.formatVariable(qb.argCounter)
	escapedKey := strings.ReplaceAll(key, "'", "''")
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s['%s'] LIKE %s", column, escapedKey, placeholder))
	qb.args = append(qb.args, pattern)
	qb.argCounter++
}

// AddMapKeyBetweenCondition adds a BETWEEN condition for a map key value
func (qb *QueryBuilder) AddMapKeyBetweenCondition(column, key string, minValue, maxValue interface{}) {
	placeholderMin := qb.formatVariable(qb.argCounter)
	qb.argCounter++
	placeholderMax := qb.formatVariable(qb.argCounter)
	qb.argCounter++
	escapedKey := strings.ReplaceAll(key, "'", "''")
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s['%s'] BETWEEN %s AND %s", column, escapedKey, placeholderMin, placeholderMax))
	qb.args = append(qb.args, minValue, maxValue)
}

// AddMapContainsCondition adds a mapContains condition
func (qb *QueryBuilder) AddMapContainsCondition(column string, key interface{}) {
	placeholder := qb.formatVariable(qb.argCounter)
	qb.conditions = append(qb.conditions, fmt.Sprintf("mapContains(%s, %s)", column, placeholder))
	qb.args = append(qb.args, key)
	qb.argCounter++
}

// AddNotMapContainsCondition adds a NOT mapContains condition
func (qb *QueryBuilder) AddNotMapContainsCondition(column string, key interface{}) {
	placeholder := qb.formatVariable(qb.argCounter)
	qb.conditions = append(qb.conditions, fmt.Sprintf("NOT mapContains(%s, %s)", column, placeholder))
	qb.args = append(qb.args, key)
	qb.argCounter++
}

// AddMapContainsAnyCondition adds a condition to check if map contains any of the given keys
func (qb *QueryBuilder) AddMapContainsAnyCondition(column string, keys []string) {
	if len(keys) == 0 {
		return
	}
	conditions := make([]string, 0, len(keys))
	for _, key := range keys {
		placeholder := qb.formatVariable(qb.argCounter)
		conditions = append(conditions, fmt.Sprintf("mapContains(%s, %s)", column, placeholder))
		qb.args = append(qb.args, key)
		qb.argCounter++
	}
	// Join with OR for any match
	qb.conditions = append(qb.conditions, fmt.Sprintf("(%s)", strings.Join(conditions, " OR ")))
}

// DateTime-specific condition methods

// AddDateTimeCondition adds a condition for DateTime columns (converts Unix timestamp to DateTime)
func (qb *QueryBuilder) AddDateTimeCondition(column, operator string, unixTimestamp uint32) {
	placeholder := qb.formatVariable(qb.argCounter)
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s %s fromUnixTimestamp(%s)", column, operator, placeholder))
	qb.args = append(qb.args, unixTimestamp)
	qb.argCounter++
}

// AddDateTimeBetweenCondition adds a BETWEEN condition for DateTime columns
func (qb *QueryBuilder) AddDateTimeBetweenCondition(column string, minTimestamp, maxTimestamp uint32) {
	placeholderMin := qb.formatVariable(qb.argCounter)
	qb.argCounter++
	placeholderMax := qb.formatVariable(qb.argCounter)
	qb.argCounter++
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s BETWEEN fromUnixTimestamp(%s) AND fromUnixTimestamp(%s)",
		column, placeholderMin, placeholderMax))
	qb.args = append(qb.args, minTimestamp, maxTimestamp)
}

// AddDateTimeInCondition adds an IN condition for DateTime columns
func (qb *QueryBuilder) AddDateTimeInCondition(column string, timestamps []uint32) {
	if len(timestamps) == 0 {
		return
	}
	placeholders := make([]string, len(timestamps))
	for i, ts := range timestamps {
		placeholders[i] = fmt.Sprintf("fromUnixTimestamp(%s)", qb.formatVariable(qb.argCounter))
		qb.args = append(qb.args, ts)
		qb.argCounter++
	}
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IN (%s)", column, strings.Join(placeholders, ", ")))
}

// AddDateTimeNotInCondition adds a NOT IN condition for DateTime columns
func (qb *QueryBuilder) AddDateTimeNotInCondition(column string, timestamps []uint32) {
	if len(timestamps) == 0 {
		return
	}
	placeholders := make([]string, len(timestamps))
	for i, ts := range timestamps {
		placeholders[i] = fmt.Sprintf("fromUnixTimestamp(%s)", qb.formatVariable(qb.argCounter))
		qb.args = append(qb.args, ts)
		qb.argCounter++
	}
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s NOT IN (%s)", column, strings.Join(placeholders, ", ")))
}

// DateTime64-specific condition methods (for microsecond precision timestamps)

// AddDateTime64Condition adds a condition for DateTime64 columns (converts Unix timestamp to DateTime64)
func (qb *QueryBuilder) AddDateTime64Condition(column, operator string, unixTimestamp uint64) {
	placeholder := qb.formatVariable(qb.argCounter)
	// DateTime64 with microsecond precision needs division by 1000000
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s %s fromUnixTimestamp64Micro(%s)", column, operator, placeholder))
	qb.args = append(qb.args, unixTimestamp)
	qb.argCounter++
}

// AddDateTime64BetweenCondition adds a BETWEEN condition for DateTime64 columns
func (qb *QueryBuilder) AddDateTime64BetweenCondition(column string, minTimestamp, maxTimestamp uint64) {
	placeholderMin := qb.formatVariable(qb.argCounter)
	qb.argCounter++
	placeholderMax := qb.formatVariable(qb.argCounter)
	qb.argCounter++
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s BETWEEN fromUnixTimestamp64Micro(%s) AND fromUnixTimestamp64Micro(%s)",
		column, placeholderMin, placeholderMax))
	qb.args = append(qb.args, minTimestamp, maxTimestamp)
}

// AddDateTime64InCondition adds an IN condition for DateTime64 columns
func (qb *QueryBuilder) AddDateTime64InCondition(column string, timestamps []uint64) {
	if len(timestamps) == 0 {
		return
	}
	placeholders := make([]string, len(timestamps))
	for i, ts := range timestamps {
		placeholders[i] = fmt.Sprintf("fromUnixTimestamp64Micro(%s)", qb.formatVariable(qb.argCounter))
		qb.args = append(qb.args, ts)
		qb.argCounter++
	}
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s IN (%s)", column, strings.Join(placeholders, ", ")))
}

// AddDateTime64NotInCondition adds a NOT IN condition for DateTime64 columns
func (qb *QueryBuilder) AddDateTime64NotInCondition(column string, timestamps []uint64) {
	if len(timestamps) == 0 {
		return
	}
	placeholders := make([]string, len(timestamps))
	for i, ts := range timestamps {
		placeholders[i] = fmt.Sprintf("fromUnixTimestamp64Micro(%s)", qb.formatVariable(qb.argCounter))
		qb.args = append(qb.args, ts)
		qb.argCounter++
	}
	qb.conditions = append(qb.conditions, fmt.Sprintf("%s NOT IN (%s)", column, strings.Join(placeholders, ", ")))
}

// GetWhereClause returns the WHERE clause if conditions exist
func (qb *QueryBuilder) GetWhereClause() string {
	if len(qb.conditions) == 0 {
		return ""
	}
	return " WHERE " + strings.Join(qb.conditions, " AND ")
}

// GetArgs returns the query arguments
func (qb *QueryBuilder) GetArgs() []interface{} {
	return qb.args
}


// Helper functions for converting filter values to interface{}

func UInt32SliceToInterface(values []uint32) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func UInt64SliceToInterface(values []uint64) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func Int32SliceToInterface(values []int32) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func Int64SliceToInterface(values []int64) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}

func StringSliceToInterface(values []string) []interface{} {
	result := make([]interface{}, len(values))
	for i, v := range values {
		result[i] = v
	}
	return result
}
// EncodePageToken encodes an offset as an opaque page token
func EncodePageToken(offset uint32) string {
	if offset == 0 {
		return ""
	}
	// Create an opaque token by base64 encoding the offset
	return base64.URLEncoding.EncodeToString([]byte(fmt.Sprintf("offset:%d", offset)))
}

// DecodePageToken decodes a page token back to an offset
func DecodePageToken(pageToken string) (uint32, error) {
	if pageToken == "" {
		return 0, nil
	}
	data, err := base64.URLEncoding.DecodeString(pageToken)
	if err != nil {
		return 0, fmt.Errorf("invalid page token format: %w", err)
	}
	var offset uint32
	n, err := fmt.Sscanf(string(data), "offset:%d", &offset)
	if err != nil || n != 1 {
		return 0, fmt.Errorf("invalid page token content")
	}
	return offset, nil
}

// CalculateNextPageToken calculates the next page token based on current offset and results
func CalculateNextPageToken(currentOffset, limit, resultCount uint32) string {
	// If we got fewer results than the limit, we've reached the end
	if resultCount < limit {
		return ""
	}
	// Calculate next offset
	nextOffset := currentOffset + resultCount
	return EncodePageToken(nextOffset)
}

// OrderByField represents a parsed order by field with direction
type OrderByField struct {
	Field string
	Desc  bool
}

// ParseOrderBy parses an AIP-132 compliant order_by string
// Format: "field1,field2 desc,field3"
func ParseOrderBy(orderBy string, validFields []string) ([]OrderByField, error) {
	if orderBy == "" {
		return nil, nil
	}

	// Create a map of valid fields for quick lookup
	validFieldMap := make(map[string]bool)
	for _, f := range validFields {
		validFieldMap[f] = true
	}

	var result []OrderByField

	// Split by comma
	parts := strings.Split(orderBy, ",")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}

		var field string
		var desc bool

		// Check if it ends with " desc"
		if strings.HasSuffix(strings.ToLower(part), " desc") {
			field = strings.TrimSpace(part[:len(part)-5])
			desc = true
		} else if strings.HasSuffix(strings.ToLower(part), " asc") {
			// Also support explicit " asc" even though it's the default
			field = strings.TrimSpace(part[:len(part)-4])
			desc = false
		} else {
			field = part
			desc = false
		}

		// Validate field name (only alphanumeric, underscore, and dots allowed)
		validFieldRegex := regexp.MustCompile("^[a-zA-Z0-9_.]+$")
		if !validFieldRegex.MatchString(field) {
			return nil, fmt.Errorf("invalid field name: %s", field)
		}

		// Check if field is valid (if validFields provided)
		if len(validFields) > 0 {
			// For subfields like "address.street", check the base field
			baseField := strings.Split(field, ".")[0]
			if !validFieldMap[baseField] {
				return nil, fmt.Errorf("invalid field for ordering: %s", field)
			}
		}

		result = append(result, OrderByField{
			Field: field,
			Desc:  desc,
		})
	}

	return result, nil
}

// BuildOrderByClause builds an ORDER BY clause from parsed order by fields
func BuildOrderByClause(fields []OrderByField) string {
	if len(fields) == 0 {
		return ""
	}

	var parts []string
	for _, f := range fields {
		if f.Desc {
			parts = append(parts, fmt.Sprintf("%s DESC", f.Field))
		} else {
			parts = append(parts, f.Field)
		}
	}

	return " ORDER BY " + strings.Join(parts, ", ")
}

// validColumnNamePattern is compiled once for performance
var validColumnNamePattern = regexp.MustCompile("^[a-zA-Z0-9_.]+$")

// isValidColumnName validates column names.
// Only allows alphanumeric characters, underscores, and dots (for nested fields)
func isValidColumnName(name string) bool {
	return len(name) > 0 && len(name) < 128 && validColumnNamePattern.MatchString(name)
}

// BuildParameterizedQuery constructs the final parameterized query with explicit column selection
func BuildParameterizedQuery(table string, columns []string, qb *QueryBuilder, orderByClause string, limit, offset uint32, options ...QueryOption) (SQLQuery, error) {
	// Apply options
	opts := &QueryOptions{}
	for _, opt := range options {
		opt(opts)
	}

	// Build FROM clause with optional database and FINAL
	var fromClause string
	if opts.Database != "" {
		fromClause = fmt.Sprintf("`%s`.%s", opts.Database, table)
	} else {
		fromClause = table
	}

	// Add projection if specified
	if opts.Projection != "" {
		fromClause = fmt.Sprintf("%s PROJECTION %s", fromClause, opts.Projection)
	}

	if opts.AddFinal {
		fromClause += " FINAL"
	}

	// Validate and build column list
	if len(columns) == 0 {
		return SQLQuery{}, fmt.Errorf("columns list cannot be empty")
	}

	escapedColumns := make([]string, 0, len(columns))
	for _, col := range columns {
		if !isValidColumnName(col) {
			return SQLQuery{}, fmt.Errorf("invalid column name: %s", col)
		}

		// Escape column names with backticks if they contain dots (for nested fields)
		// or if they might be reserved words.
		if strings.Contains(col, ".") {
			// For nested fields like "abc.xyz", escape each part.
			parts := strings.Split(col, ".")
			escapedParts := make([]string, len(parts))
			for i, part := range parts {
				escapedParts[i] = fmt.Sprintf("`%s`", part)
			}
			escapedColumns = append(escapedColumns, strings.Join(escapedParts, "."))
		} else {
			escapedColumns = append(escapedColumns, fmt.Sprintf("`%s`", col))
		}
	}

	columnList := strings.Join(escapedColumns, ", ")
	query := fmt.Sprintf("SELECT %s FROM %s", columnList, fromClause)

	// Add WHERE clause
	query += qb.GetWhereClause()

	// Add ORDER BY clause
	query += orderByClause

	// Add LIMIT and OFFSET
	if limit > 0 {
		query += fmt.Sprintf(" LIMIT %d", limit)
		if offset > 0 {
			query += fmt.Sprintf(" OFFSET %d", offset)
		}
	}

	return SQLQuery{
		Query: query,
		Args:  qb.GetArgs(),
	}, nil
}
